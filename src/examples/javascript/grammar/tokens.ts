import { LexerToken } from '../../../types'
import { keywords } from './keywords'

export const tokens: LexerToken[] = [
  {
    name: 'BEGINCOMMENT',
    test: /^\/\*/,
    begin: 'COMMENT',
  },
  {
    name: 'NEWLINE',
    test: /^[\n\r]/,
    lineBreaks: true,
    shouldTokenize: lexer => {
      // const nextToken = lexer.peak()

      /*
        If set to true newlines are tokenized.
      */

      // return nextToken && nextToken.name === 'NEWLINE' ? false : true

      return false
    },
  },
  {
    name: 'NULL',
    test: /^null/,
    value: () => null,
  },
  {
    name: 'NUMBER',
    test: /^[0-9]+(?:\.?[0-9]+)*/,
    value: parseFloat,
  },
  {
    name: 'STRING',
    test: /^((?:"(?:[^"\\]|(?:\\.))*")|'(?:[^'\\]|(?:\\.))*')/,
    value: str => str.slice(1, -1),
  },
  {
    name: 'INTERFACE',
    test: 'interface',
    // begin: 'INTERFACE',
  },
  {
    name: 'TYPE',
    test: 'type',
    // begin: 'TYPE',
  },
  'THIS',
  'FALSE',
  'TRUE',
  'SWITCH',
  'CASE',
  'DEFAULT',
  'NEW',
  'TRY',
  'CATCH',
  'FINALLY',
  'THROW',
  'DO',
  'WHILE',
  'FUNCTION',
  'RETURN',
  'BREAK',
  'CONTINUE',
  'VOID',
  'AS',
  'FROM',
  'DELETE',
  'CONST',
  'LET',
  'VAR',
  'IF',
  'ELSE',
  'FOR',
  'IN',
  'OF',
  'TYPEOF',
  'INSTANCEOF',
  'IMPORT',
  'EXTENDS',
  'PUBLIC',
  'PROTECTED',
  'PRIVATE',
  'OVERRIDE',
  'ABSCTRACT',
  'GET',
  'SET',
  'IMPLEMENTS',
  'ASSERTS',
  'IS',
  'READONLY',
  'KEYOF',
  'UNIQUE',
  'INFER',
  {
    name: 'IDENTIFIER',
    test: /^[$a-zA-Z]+(?:[a-zA-Z_\-]+)*/,
    guard: (match: string) => !keywords.includes(match),
  },
  ['SEMI', ';'],
  ['COMMA', ','],
  ['DOT', '.'],
  ['DOUBLECOLON', '::'],
  ['COLON', ':'],
  ['PLUSIS', '+='],
  ['MULTIPLY', '*'],
  ['DIVIDE', '/'],
  ['INCREMENT', '++'],
  ['MODULUS', '%'],
  ['PLUS', '+'],
  ['DECREMENT', '--'],
  ['MINUS', '-'],
  ['TENARY', '?'],
  ['ARROW', '=>'],
  ['NOTSTRICTEQUAL', '!=='],
  ['STRICTEQUAL', '==='],
  ['EQUALEQUAL', '=='],
  ['NOTEQUAL', '!='],
  ['LOGNOT', '!'],
  ['EQUAL', '='],
  ['LANGLEBRACKET', '<'],
  ['LTEQ', '<='],
  ['RANGLEBRACKET', '>'],
  ['GTEQ', '>='],
  ['LOGOR', '||'],
  ['XLOGOR', '^'],
  ['LOGAND', '&&'],
  ['BINOR', '|'],
  ['NOT', '~'],
  ['BINAND', '&'],
  ['LPAREN', '('],
  ['RPAREN', ')'],
  ['LCBRACE', '{'],
  ['RCBRACE', '}'],
  ['LBRACK', '['],
  ['RBRACK', ']'],
]
